<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: xUnitBDDExtensions | Dude, where's my Kaizen?]]></title>
  <link href="http://www.bjoernrochel.de/blog/categories/xunitbddextensions/atom.xml" rel="self"/>
  <link href="http://www.bjoernrochel.de/"/>
  <updated>2011-11-06T22:05:04+01:00</updated>
  <id>http://www.bjoernrochel.de/</id>
  <author>
    <name><![CDATA[Björn Rochel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[xUnit.BDDExtensions now runs with xUnit 1.5 final]]></title>
    <link href="http://www.bjoernrochel.de/2009/09/09/xunitbddextensions-now-runs-with-xunit-15-final/"/>
    <updated>2009-09-09T23:25:33+02:00</updated>
    <id>http://www.bjoernrochel.de/2009/09/09/xunitbddextensions-now-runs-with-xunit-15-final</id>
    <content type="html"><![CDATA[<p>I've just upgraded the trunk to the final 1.5 version of <code>xUnit</code> released last week. This update now allows BDDExtensions to be used with the
latest version independant resharper runner for xUnit from xunitcontrib.</p>

<p>Current Version is 1.0.1.16. You can download it <a href="http://xunitbddextensions.googlecode.com/files/xunit.bddextensions.1.0.1.16.zip">here</a>
or get the latest sources from the <a href="http://xunitbddextensions.googlecode.com/svn/trunk/">trunk</a>.</p>

<p>Happy specifying . . .</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xUnit.BDDExtensions update]]></title>
    <link href="http://www.bjoernrochel.de/2009/09/07/xunitbddextensions-update/"/>
    <updated>2009-09-07T09:07:51+02:00</updated>
    <id>http://www.bjoernrochel.de/2009/09/07/xunitbddextensions-update</id>
    <content type="html"><![CDATA[<p>xUnit.BDDExtensions now uses <code>Rhino.Mocks 3.6</code> internally. I've just updated the trunk. As usual you can find it here:</p>

<p><a href="http://github.com/bjro/xunitbddextensions">http://github.com/bjro/xunitbddextensions</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[That’s why I like Open Source . . .]]></title>
    <link href="http://www.bjoernrochel.de/2009/07/08/thats-why-i-like-open-source/"/>
    <updated>2009-07-08T23:19:01+02:00</updated>
    <id>http://www.bjoernrochel.de/2009/07/08/thats-why-i-like-open-source</id>
    <content type="html"><![CDATA[<p>Today I received a really nice feature for xUnit.BDDExtensions from a
former colleague and friend of mine. It came to me completely with a
spec demonstrating and documenting its usage. Completely awesome. I wish
day to day software development would always be like that.</p>

<p>The feature deals with chained properties on interfaces. Consider the
following example: A presenter working against a composed passive view.</p>

<p>``` csharp A complex MVP view interface
public interface IComplexView
{</p>

<pre><code>ISubView Header {get;set;} 
</code></pre>

<p>}</p>

<p>public interface ISubView
{</p>

<pre><code>string Description {get;set;} 
</code></pre>

<p>}
public class Presenter
{</p>

<pre><code>private IComplexView _view;

public Presenter(IComplexView view)
{
    _view = view; 
}

public void Initialize() 
{ 
    _view.Header.Description = "Some caption . . ." 
} 
</code></pre>

<p>}
```</p>

<p>A spec documenting the behavior of the presenter can now look
like this if you're using xUnit.BDDExtensions.</p>

<p>``` csharp Using the HasProperties() extension method
[Concern(typeof(Presenter))]
public class When_the_presenter_is_initialized : InstanceContextSpecification<Presenter>
{</p>

<pre><code>protected override EstablishContext() 
{ 
    The&lt;IComplexView&gt;().HasProperties(); 
}

protected override void Because() 
{ 
    Sut.Initialize(); 
} 

[Observation]
public void It_should_set_the_headers_caption() 
{
    The&lt;IComplexView&gt;().Header.Description.ShouldBeEqualTo("Some caption ... ");
}
</code></pre>

<p>}
```</p>

<p>A really large portion of the necessary glue code has been
removed for that scenario. Only the <code>HasProperties()</code> extension method
remains.</p>

<p>Great work, Sergey. I really like the implementation of that feature ...</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I shot me again . . .]]></title>
    <link href="http://www.bjoernrochel.de/2009/07/07/i-shot-me-again/"/>
    <updated>2009-07-07T21:41:37+02:00</updated>
    <id>http://www.bjoernrochel.de/2009/07/07/i-shot-me-again</id>
    <content type="html"><![CDATA[<p>Earlier the day I wrote about my recent experience with <code>ILMerge</code>. As it turns out there were still some <code>Rhino.Mocks</code> related types which had to
be excluded (The ones related to the <code>WhenToldTo</code> / <code>WasToldTo</code> functionality). This issue should be fixed now with my last check-in.</p>

<p>Damn it ;-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to shoot yourself in the foot with ILMerge]]></title>
    <link href="http://www.bjoernrochel.de/2009/07/07/how-to-shoot-yourself-in-the-foot-with-ilmerge/"/>
    <updated>2009-07-07T18:48:04+02:00</updated>
    <id>http://www.bjoernrochel.de/2009/07/07/how-to-shoot-yourself-in-the-foot-with-ilmerge</id>
    <content type="html"><![CDATA[<p>xUnit.BDDExtensions and is now completely merged into a single assembly.
However, getting to that state wasn't as straight forward as I
originally expected.</p>

<h2>The initial problem</h2>

<p>xUnit.BDDExtensions internally depends on StructureMap,
StructureMap.AutoMocking and Rhino.Mocks. However, I don't like the need
to carry around 3 extra assemblies with me, especially if I don't use
them directly in the xUnit.BDDExtensions API. So I decided to give
<a href="http://research.microsoft.com/en-us/people/mbarnett/ilmerge.aspx">ILMerge</a>
a try and started with this: \</p>

<p>``` bash
ILMerge.exe /t:library /out:'Deploy/xUnit.BDDExtensions.dll'</p>

<pre><code>'xUnit.BDDExtensions.dll'
'StructureMap.dll' 
'StructureMap.AutoMocking.dll' 
'Rhino.Mocks.dll'
</code></pre>

<p>```</p>

<p>Initial merging went fine, but when I tried to actually use the merged
assembly in a solution also containing a StructureMap binary, I received
a lot of build errors indicating duplicate types. The solution simply
didn't compile any more. Crap !</p>

<h2>What went wrong</h2>

<p>The way I merged the assemblies, all public types of the dependent
assemblies stayed public (although they're only internally used). The
merged assembly exposed all public APIs of the merged-in assemblies.
When using the assembly in conjunction with one of the original
assemblies (for instance StructureMap) the compiler basically didn't
know which type my code was actually referring to. Hence the error.</p>

<p>Besides the observed effect those APIs can clearly be confusing to a
developer with no knowledge that the assembly at hand is actually a
merged one. So imho definitely a situation which needed to be fixed.</p>

<h2>How to fix it</h2>

<p>What needed to be done is to internalize the all public types of the
merged-in assemblies. The related switch for this in ILMerge is <code>/internalize</code>.</p>

<p>``` bash
ILMerge.exe /t:library /internalize</p>

<pre><code>    /out:'Deploy/xUnit.BDDExtensions.dll' 
    'xUnit.BDDExtensions.dll'
    'StructureMap.dll' 
    'StructureMap.AutoMocking.dll' 
    'Rhino.Mocks.dll'
</code></pre>

<p>````
The solution using both xUnit.BDDExtensions and StructureMap now
compiled without errors. Duplicate type issue solved. Everything fine
now? Nope, obviously internalization created some other problems: Specs
driven by xUnit.BDDExtensions showed that neither the auto-mocking
feature nor the mock support worked anymore. Nearly every test failed
due to an internal exception.</p>

<h2>How to fix it (Take 2) </h2>

<p>The problem with the internalization of all public types is that
sometimes the merged APIs somehow depend on several types being public.
If you take that away, you effectively break their functionality. In my
case my problems where created by Castle.DynamicProxy2 (which is used by
Rhino.Mocks internally) and StructureMap. Both tools are doing dynamic
type generation internally and the generated types wanted to implement
some interfaces which were formally public but now weren't accessible
any more. To my luck ILMerge provides a workaround for situations like
that: You can exclude types from being internalized. Here's what I did
in order to make it work:</p>

<p>``` bash
ILMerge.exe /t:library</p>

<pre><code>/internalize:'Build/ILMergeIncludes.txt'
/out:'Deploy/xUnit.BDDExtensions.dll'
'xUnit.BDDExtensions.dll'
'StructureMap.dll'
'StructureMap.AutoMocking.dll' 
'Rhino.Mocks.dll'
</code></pre>

<p><code>``
Notice the modified</code>/internalize` switch. A file now specifies the
types to exclude from the internalization. ILMerge expects the file to
contain a regular expression per line. Every line is evaluated against
each type name and automatically excluded from the internalization
process in case the regular expression matches. My exclude file looks
like this:</p>

<p><code>csharp
StructureMap.InstanceBuilder
StructureMap.Pipeline.\*
Rhino.Mocks.Interfaces.IMockedObject
Castle.Core.Interceptor.IProxyTargetAccessor
Castle.DynamicProxy.AbstractInvocation
Castle.DynamicProxy.Generators.AttributesToAvoidReplicating
</code></p>

<h2>Lessons learned </h2>

<p>Merging for deployment isn't that hard, but you have to be careful
that everything works as expected after you've created the merged
assembly. A successful ILMerge call doesn't necessarily mean that
everything's fine and works as expected. On the other hand the ILMerge
documentation is very good and provided me with a simple solution to the
problem. I've shot myself in the foot, but it's bandaged and I can walk
again, so to say. If you're interested in doing something similar (not
the shooting part) I highly suggest that you should give ILMerge a try .
. .</p>

<h2>Sidenotes</h2>

<p>Is it possible that ILMerge fails to merge WPF based assemblies? I'm
currently experiencing strange effects when trying to merge them. Anyone?</p>
]]></content>
  </entry>
  
</feed>

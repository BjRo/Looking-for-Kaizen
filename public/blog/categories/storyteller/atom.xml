<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: StoryTeller | Dude, where's my Kaizen?]]></title>
  <link href="http://www.bjoernrochel.de/blog/categories/storyteller/atom.xml" rel="self"/>
  <link href="http://www.bjoernrochel.de/"/>
  <updated>2011-11-06T22:55:22+01:00</updated>
  <id>http://www.bjoernrochel.de/</id>
  <author>
    <name><![CDATA[Björn Rochel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Diving into the StoryTeller trunk, Part 11.3: Commands strike back]]></title>
    <link href="http://www.bjoernrochel.de/2010/02/15/diving-into-the-storyteller-trunk-part-11-3-commands-strike-back/"/>
    <updated>2010-02-15T20:21:20+01:00</updated>
    <id>http://www.bjoernrochel.de/2010/02/15/diving-into-the-storyteller-trunk-part-11-3-commands-strike-back</id>
    <content type="html"><![CDATA[<p>One of the things that can hit you really hard when writing blog posts about open source software (like StoryTeller is),
is the fact that your posts tend to get very fast outdated, especially when you don't pay that much attention to the detail (like I did, sigh).
If you're not aware of what I'm talking about, it's StoryTellers command story. I'm not sure when it changed but it definitely has changed and I
needed to update my last post <a href="/2010/01/09/diving-into-the-storyteller-trunk-part-11-2-more-on-commands/">11.2</a> quite a bit in order
to reflect the changes. Today I would like to conclude my trip through StoryTellers UI infrastructure with a look at how Commands are integrated
into the Screen Activation Lifecycle.</p>

<!--more-->


<p>Some of my older posts on the topic showed that the component responsible for Screen activation and deactivation in StoryTeller is the <code>ScreenConductor</code>.
However, when the <code>ScreenConductor</code> activates or deactivates a Screen, it delegates a major part of work to the so called <code>IShellService</code>.
The only implementer of this interface, the <code>ShellService</code>, is just a little facade around three things.</p>

<ol>
<li>The <code>ICommandbar</code>, which is the main toolbar of StoryTeller,</li>
<li>the <code>IOptionsMenu</code>, which is a kind of Shortcut menu for StoryTellers Commands and</li>
<li>the <code>IScreenObjectRegistry</code>, which acts as a store  / front-end for the current Command registration.</li>
</ol>


<p>``` csharp The ShellService</p>

<pre><code>public class ShellService : IShellService
{
    private readonly ICommandBar _Commands;
    private readonly IOptionsMenu _options;
    private readonly IScreenObjectRegistry _registry;

    public ShellService(
          IScreenObjectRegistry registry, 
          ICommandBar Commands, 
          IOptionsMenu options)
    {
        _registry = registry;
        _Commands = Commands;
        _options = options;
    }

    #region IShellService Members

    public void ActivateScreen(IScreen screen)
    {
        _registry.ClearTransient();
        screen.Activate(_registry);
        refill();
    }

    public void ClearTransient()
    {
        _registry.ClearTransient();
        refill();
    }

    public void Start()
    {
        refill();
    }

    #endregion

    private void refill()
    {
        _Commands.Refill(_registry.Actions);
        _options.Refill(_registry.Actions);
    }
</code></pre>

<p>```</p>

<p>You can see some interesting aspects in the short code above.</p>

<ol>
<li>The word transient appears several times. StoryTeller differentiates between two types of Commands:
Permanent Commands and transient Commands. Permanent Commands are displayed, well permanently, while transient Commands are
what I depicted as contextual Commands. They are Commands which should be only visible in a particular context.</li>
<li>Contextualization of Commands is handled on a per Screen basis in StoryTeller. Every time a Screen gets activated or
deactivated the <code>ICommandBar</code> and the <code>IOptionsMenu</code> get reset and completely rebuild. With this you can have a very different Command UI
depending on which Screen is activated.</li>
<li>The actual Command configuration in the Screen Activation Lifecycle is completely delegated to the active Screen. In his <code>Activate()</code> method he
receives a reference to the <code>IScreenObjectRegistry</code> which can be used in order to start the Command configuration via a small fluent API.</li>
</ol>


<p>``` csharp IScreenObjectRegistry</p>

<pre><code>public interface IScreenObjectRegistry
{
    //Gets a collection of all currently known command configurations  
    IEnumerable&lt;ScreenAction&gt; Actions { get; }

    //Removes all transient command configurations from the registry
    void ClearTransient();

    //DSL starting point for the configuration of transient Commands
    IActionExpression Action(string name);

    //DSL starting point for the configuration of permanent Commands
    IActionExpression PermanentAction(string name);
}
</code></pre>

<p>```</p>

<p>The following code snippet shows an example of how this API could be leveraged inside a Screen.</p>

<p>``` csharp Inside a screen</p>

<pre><code>    public void Activate(IScreenObjectRegistry screenObjects)
    {
        screenObjects
            .Action("Save")
            .Bind(ModifierKeys.Control, Key.S)
             .To(_save); //This can be either Systen.Action or an System.Windows.Input.ICommand

        screenObjects
            .Action("Cancel")
            .Bind(Key.Escape)
            .To(_cancel);
    }
</code></pre>

<p>```</p>

<p>Gabriel Schenker has <a href="http://www.lostechies.com/blogs/gabrielschenker/archive/2010/01/08/fluent-silverlight-table-of-content.aspx">written an excellent series on how to write such a fluent API</a>.
Although it's targeting Silverlight, most of the involved problems are explained in detail there, so forgive me if I don't dive into the actual DSL implementation.</p>

<h2>Some final thoughts</h2>

<p>Making the Screen responsible for setting up his Commands makes a lot of sense to me, since the Screen is the unit which gets plugged into the UI infrastructure
and it also very likely plays the role of the Command receiver in terms of the classic GoF pattern description.
This doesn't necessary mean that Screens are the only place for Command configuration.
The initialization of modules in a Composite application is also a very likely place for registration of permanent Commands.</p>

<p>I consider having a fluent API for configuring the Commands also a plus, because it IMHO makes the actual Command configuration a lot easier and accessible.
I've used the same setup (fluent API + delegation to screen) on my last 3 projects and it always worked for me like a charm.</p>

<p>Like I mentioned in the previous post, what I don't like that much is the idea of mixing in visual aspects (Icon, Size, Location) into the Command configuration,
mostly because I've been burned by this in the past when facing complex menus, like the ribbon.
I think it's a good idea to externalize the visual aspect via XML, at least for all the static stuff.</p>

<h2>This is it</h2>

<p>This was the last post about StoryTeller (at least for a while). It has been an interesting voyage which taught me a lot about UI infrastructure design,
StructureMap usage and Convention over Configuration. Although it was primarily my learning excercise I hope you took something interesting with you
from this blog series, too.</p>

<p>I'm going to continue my research on UI architecture with another deep dive into <a href="http://devlicio.us/blogs/rob_eisenberg/default.aspx">Rob Eisenbergs</a> <a href="http://www.codeplex.com/caliburn">Caliburn</a> soon.
If your interested I would be very happy to have you with me on that trip . . .</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diving into the StoryTeller trunk, Part 11.2: More on Commands]]></title>
    <link href="http://www.bjoernrochel.de/2010/01/09/diving-into-the-storyteller-trunk-part-11-2-more-on-commands/"/>
    <updated>2010-01-09T20:38:35+01:00</updated>
    <id>http://www.bjoernrochel.de/2010/01/09/diving-into-the-storyteller-trunk-part-11-2-more-on-commands</id>
    <content type="html"><![CDATA[<p>Let’s take a look at some of the questions I left unanswered in the last post.</p>

<h2>Is the basic GoF Command pattern sufficient for a modern composite application?</h2>

<p>The basic GoF Command pattern has no notion of visual state of a <code>Command</code>, such as <code>(Is)Enabled</code> or <code>(Is)Visible</code>.
Its original purpose was to encapsulate an action, so that it can be passed around and executed at some later point of time. Not more, not less.</p>

<p>``` csharp The basic Command interface
public interface ICommand
{</p>

<pre><code>void Execute(); 
</code></pre>

<p>}
```</p>

<p>Obviously real world desktop apps need something a bit more sophisticated. I’ve seen several infrastructures in my (not so old)
career so far (home grown as well as OS alternatives), which extended this basic idea with at least one of those properties mentioned above.
Take for instance the P&amp;P Composite UI Application Block (now better known as part of the Smart Client Software Factory). CAB implements a
delegate based variation on the Command pattern. The delegate represents the action which is passed around. However, this delegate is managed by
the Command class which has a notion of Status.</p>

<p>``` csharp CommandStatus in CAB
public enum CommandStatus
{</p>

<pre><code>Enabled, //visible and enabled
Disabled, //visible and disabled 
Unavailable //invisible 
</code></pre>

<p>}
```</p>

<p>The WPF Command infrastructure version of the Command interface is more like the original pattern and adds the <code>Enabled</code> Property and an <code>EnabledChangedEvent</code> to the interface definition.</p>

<p>``` csharp WPFs ICommand interface
public interface ICommand
{</p>

<pre><code>void Execute(); 
bool Enabled { get; } 
event EventHandler EnabledChanged; 
</code></pre>

<p>}
```</p>

<p>To be honest, the <code>Command</code> interface <strong>never looked like the original GoF definition in
ANY APPLICATION or project I’ve worked on so far</strong>. It always had a slight modification in one or another way.</p>

<h2>StoryTeller’s Command interface</h2>

<p>StoryTeller is a WPF based application, so naturally it gets the WPF Command infrastructure out of the box. However it composes the
WPF <code>ICommand</code> into a StoryTeller specific structure, the <code>IScreenAction</code>.</p>

<p>``` csharp The ScreenAction abstraction
public interface IScreenAction
{</p>

<pre><code>bool IsPermanent { get; set; } 
InputBinding Binding { get; set; } 
string Name { get; set; } 
Icon Icon { get; set; } 
ICommand Command { get; } 
bool ShortcutOnly { get; set; } 
void BuildButton(ICommandBar bar); 
</code></pre>

<p>}
```</p>

<p><code>IScreenAction</code> extends the capabilities of the original GoF-Pattern with a lot of metadata, mostly for visual aspects (Icon, Description).
If you’re wondering why he included visual aspects: That basically tries to solve a reoccurring problem in composite apps: In
composite applications modules are not known at compile time to the infrastructure. Neither are all their capabilities and how they might be
displayed in the infrastructure shell. Because of that, the infrastructure needs a dynamic, deferred way for doing the shells visual
configuration at application startup. One way to implement this is to delegate the responsibility for setting this up to the modules itself.
This can be done during the module load time or every time a screen is displayed. This fits very well with the idea of the Open Closed
Principle, since adding new modules/screens doesn’t require any reconfiguration/recompilation of other modules or the infrastructure.
This is more or less the approach that StoryTeller takes.</p>

<h2>Some personal thoughts on IScreenAction</h2>

<p>I’ve worked on three applications in the past which followed down the same road. One thing I noticed
throughout those three applications is that this approach isn’t really well suited when you’ve got strict and/or complex requirements about how
the UI of an application should look. Let me clarify a bit what I mean:</p>

<ul>
<li><strong>The Ordering Problem</strong>. Even if you organize tools representing commands in a simple toolbar (as StoryTeller does) you can very
easily get into situations where the product owner wants to have the tools in a very specific order which is different to module load
order, some internal event order, whatever. I’ve encountered this several times now. First time we solved this by introducing a global
constant class containing tool names. Very, very bad idea, do not repeat this. This introduces a kind of hidden temporal coupling,
because now modules must be loaded in a particular order (so that a tool already exists to which we can refer by name). StoryTellers
take on this is a bit better (but IMHO not much). The Icon class has an Integer based Order property. All tools get sorted based on this
property in StoryTellers CommandBar when it’s reloaded. This is less coupled, because it eliminates the temporal aspect of the coupling,
but still has coupling.</li>
<li><strong>API bloat with visual aspects</strong>. One area where I really started to find this approach annoying is when you stop having simple
toolbars and start to use more complex menu types like for instance the Ribbon. Taking the ribbon as an example: Now don’t have simply
an ordering problem, but at minimum an icon problem (Normal icon vs.  Quick Access Toolbar), a size problem (Displayed large or small) and
a positioning problem (/Tab/Group/ElementGroup vs.  /ApplicationMenu/Left). We added all those stuff to our Command
registration and guess what, we weren’t happy with that. We created a monster API actually doing very little.</li>
</ul>


<p>So what do I (currently) prefer? Our current project (also using the Ribbon) completely strips the visual aspect of the Command. Our Command
API looks very much like the WPF one, with the only addition of an Id property. The whole visual aspect is configured using an XML file which
is loaded at application startup.</p>

<p>``` csharp Using xml to wire up the ribbon
<Ribbon>
   <Tab></p>

<pre><code>  &lt;Group&gt;
     &lt;Button imageId=”CancelIcon“ commandId=”CommandXYZ” /&gt;
  &lt;/Group&gt;
</code></pre>

<p>   </Tab>
</Ribbon>
```</p>

<p>I think you get the point. It works very well for our scope. (Slight warning though: This solution might not be the best in
case you need to represent menu state based on dynamically loaded data).</p>

<p>See you next time for: Commands strike back ;-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diving into the StoryTeller trunk, Part 11.1: Commands]]></title>
    <link href="http://www.bjoernrochel.de/2009/12/23/diving-into-the-storyteller-trunk-part-111-commands/"/>
    <updated>2009-12-23T20:16:13+01:00</updated>
    <id>http://www.bjoernrochel.de/2009/12/23/diving-into-the-storyteller-trunk-part-111-commands</id>
    <content type="html"><![CDATA[<p>Welcome back to the <strong>Diving into the StoryTeller trunk</strong> series. The main
topic for the last couple of posts about StoryTeller is its Command handling or to be a bit more specific the reoccurring problem of how
Screen related Commands are managed in the app infrastructure. Couple of posts? Yeah, right. Today's post is going to be a bit shorter than the
usual posts in the series. When I started to write this post I quickly realized that this topic contains more aspects to talk about than I had
originally anticipated. Besides that Christmas is near, I'm running out of time for this year and just wanted to get at least some bits of the
content out there before going on vacation. Today's post is going to be more general one on the topic.</p>

<h2>The Command Pattern </h2>

<p>A lot of the content in this series dealt exclusively with how the StoryTeller UI layer manages Screens in its content area,
but as you know most of the time an application consists of more parts than just the plain content area. A typical desktop application is probably going to have some sort
of Mainmenu, a Statusbar and of course Contextmenus. Items displayed in those areas very often represent actions an application can perform.
They act as a trigger of those actions. A typical way to implement this is using the <a href="http://en.wikipedia.org/wiki/Command_pattern">GoF-Command Pattern</a>, which separates
the invoker of an action (for instance a button) from the receiver instance which executes the action by introducing the Command abstraction. A Command encapsulates the knowledge needed for an
invokation of the receiver instance, so that it can be executed at a later time.</p>

<h2>Commands are potentially contextual </h2>

<p>An application can have lots and lots of Commands. While some of these Commands are available all of the time, some of them can only be executed in a particular context.
A typical example for Commands of the first category might be the "Exit application" Command. A typical example for the latter category might be the "Undo" Command or "Redo" Command in all
kinds of text editors, which can only be executed when the currently viewed document has some changes. It's not uncommon to have lots of contextual Commands in an application that are only related to a very
specific Screen or Screen state. When we think in terms of usability, the least a user should be able to take granted from an app is that the
app appropriately shows which actions can be performed at a particular point of time. This can be achieved by enabling / disabling related
items depending on the availability of the Command (be it manually or through databinding). Sometimes though,it might be a better approach to
have an even more contextualized UI that only shows the commands related to the current context. So for instance if no code editor view is shown
in Visual Studio than the "Undo" and "Redo" Commands should also not be visible (NOTE: VS doesn't actually behave that way). I think this idea
of contextualized UIs becomes more and more popular. Office 2007/2010 was build with this idea in mind.</p>

<h2>Commands in a Composite UI</h2>

<p>Composite UIs which follow the Open / Closed Principle add another problem to the mix. When new modules or new screens are loaded into a
composite app, they shouldn't need to modify the app infrastructure in order to add their related commands. The app infrastructure needs to
provide a way to plug those commands in without modification. This also includes their visual representation (Text, Tooltip, Icon, etc.).</p>

<h2>Questions we should take a closer look at</h2>

<ul>
<li>Do we need to differentiate between types of Commands?</li>
<li>Who is responsible for adding / registering commands?</li>
<li>How is the visual representation of commands configured?</li>
<li>Who is responsible for deciding whether Commands are available?</li>
<li>Is there build-in .NET Framework support for this?</li>
<li><strong>Of course: How does StoryTeller implement all this?</strong></li>
</ul>


<p>I'm afraid that's all for today. I wish you all merry Christmas and a
happy new year. See you in 2010</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diving into the StoryTeller trunk, Part 10: Coordination Baby!]]></title>
    <link href="http://www.bjoernrochel.de/2009/11/30/diving-into-the-storyteller-trunk-part-10-coordination-baby/"/>
    <updated>2009-11-30T10:13:22+01:00</updated>
    <id>http://www.bjoernrochel.de/2009/11/30/diving-into-the-storyteller-trunk-part-10-coordination-baby</id>
    <content type="html"><![CDATA[<p>So far in this series I've talked extensively about what I consider the
most of the important parts in the StoryTeller UI design. This includes
<a href="/2009/08/14/diving-into-the-storyteller-trunk-part-7-screens/">Screens</a>,
<a href="/2009/08/21/diving-into-the-storyteller-trunk-part-8-the-screencollection/">the ScreenCollection</a>,
<a href="/2009/09/07/diving-into-the-storyteller-trunk-part-9-screensubject-screenfactory/">ScreenSubject</a>,
<a href="/2009/09/07/diving-into-the-storyteller-trunk-part-9-screensubject-screenfactory/">ScreenFactory</a>,
<a href="/2009/07/20/diving-into-the-storyteller-trunk-part-5-the-eventaggregator/">EventAggregation</a>
and the application of <a href="/2009/07/13/diving-into-the-storyteller-trunk-part1-convention-based-registration/">Convention of Configuration</a>
in general. You could say that we mostly talked about ingredients. Today
I would like to take some additional time in order to show how this is
all assembled into an actual API. Those of you who've already spend
some time with the StoryTeller codebase too or have watched one of the
many screencasts about the <a href="http://www.jeremydmiller.com/ppatterns/Default.aspx?Page=ScreenActivationLifecycle&amp;AspxAutoDetectCookieSupport=1">Screen Activation Lifecycle</a>
probably know what I'm going to show today. Today is all about the
<code>ScreenConductor</code>.</p>

<h2>ScreenConductor vs. Application Controller</h2>

<p>Before we dive into the actual code, let's take a short break and talk a
little bit about a more high level view on the <code>ScreenConductor</code> and the
role the conductor is fulfilling in an application. Martin Fowler
identified the pattern <code>ApplicationController</code> some years ago as</p>

<p><blockquote><p>A centralized point for handling screen navigation and the flow of an<br/>application.</p><footer><strong>Martin Fowler</strong><cite><a href='http://martinfowler.com/eaaCatalog/applicationController.html'>martinfowler.com/eaaCatalog/&hellip;</a></cite></footer></blockquote></p>

<p>It's kind of a coordination structure which manages / coordinates the
lifecylcle of child screens in an application as well as the lifecycle
of the application shell itself (think about controlled shutdown for
instance). You can think of the <code>ApplicationController</code> as a <em>Facade</em> client
code can call in order to create/activate/deactivate screens in an
application. This <em>Facade</em> defines a nice separation between application
code on the one side and the UI infrastructure on the other side. It
shields away implementation details of how the application is actually
displaying screens (tab style, web style, etc) from the client and also
provides a nice point for handling scenarios like dirty checks on
screens. As an application grows over time, it's a good idea to break
down the <code>ApplicationController</code> into several collaborating classes and
decouple its implementation details from another in order to make the
system more manageable and maintainable. Adding a new screen to the
application for instance should not require a change in one of the UI
infrastructure classes. When breaking down the <code>ApplicationController</code>
into several collaborating classes a good lead is to use the <em>Single
Responsibility Principle</em> in order to identify responsibilities which can
be extracted.</p>

<p>That's exactly what Jeremy D. Miller did in his <a href="http://www.jeremydmiller.com/ppatterns/Default.aspx?Page=ScreenActivationLifecycle&amp;AspxAutoDetectCookieSupport=1">Screen Activation Lifecycle</a>.
He broke down the ApplicationController pattern into several smaller
responsibilities, the most important beeing</p>

<ul>
<li>the <code>ScreenCollection</code> (which keeps track of all existing screens and the one beeing the active screen)</li>
<li>the <code>ScreenSubject</code> (which is used to separate identification and creation of a screen from the screen itself)</li>
<li><code>Screens</code> (which provide the content beeing displayed and hooks for instance for the dirty check when the application closes)</li>
<li>and the <code>ScreenConductor</code>.</li>
</ul>


<p>Jeremy describes the <code>ScreenConductor</code> and its responsibilities as the
following:</p>

<p><em>"Controls the activation and deactivation lifecycle of the
screens within the application. Depending on the application, the
conductor may be synchronizing the menu state of the shell, attaching
views in the main panel or otherwise, and calling hook methods on the
Presenter's to bootstrap the screen. It may also be just as important to
deactivate a screen when it's made the inactive tab to stop timers. My
first exposure to a ScreenConductor was an insurance application that
was built with web style navigation. Anytime the user moved away from a
screen we needed to check for "dirty" screens to give the user a chance
to deal with unsaved work. On the other hand, we also had to check the
entry into a requested screen to see if we could really open the screen
based on pessimistic locking or permission rules. We pulled our a Layer
SuperType for our Presenters for methods like CanLeave() and CanEnter().
The ScreenConductor would use these methods and others to manage screen
navigation."</em></p>

<p>To me the ScreenConductor is more or less an OCP-fied
subset of the original <code>ApplicationController</code> pattern, focussing on the
coordination and facade ideas of the original pattern.</p>

<h2>A short episode in the Screen Activation Lifecycle </h2>

<p>Let's give our discussion a bit more detail. So far it was rather abstract. Before looking into the
actual code I would like to walk you through a typical usecase which
depicts how those components actually work together. The example Jeremy
mostly uses for this is "Opening a source code file in Visual Studio" .
I'm lazy, so I'm going to reuse this one.</p>

<p><em>"Consider you double-click a file in the Solution Explorer of VS. When you do this for the first
time a new tab displaying the contents of the file will be opened. Doing
the same thing a second time will not open a new tab, but rather focus
the existing tab displaying the contents of the file."</em></p>

<p>It's actually easy to translate this story into a more abstract version using the
responsibilities described in this post so far.</p>

<p><em>"Consider you want to open a <code>Screen</code> via a <code>ScreenSubject</code>. When the <code>ScreenSubject</code>
detects that no related <code>Screen</code> is being displayed to the user, a new
<code>Screen</code> will be created by the subject and then added to the
<code>ScreenCollection</code>. Doing the same thing a second time will not open
up a <code>Screen</code>, but rather activate the existing <code>SCREEN</code>, because
the <code>ScreenSubject</code> detected that the <code>Screen</code> is already open."</em></p>

<p>The interesting sidenode in this design is that from a client code
perspective there is no difference between opening up a screen and
activating a screen. Really nice . . .</p>

<h2>Usecase: Opening a Screen </h2>

<p>Now that you're familiar with the first scenario, time to show some code.  I've shown parts of this before in the previous post (Sorry for the
duplication), but added some bits in order to illustrate this example.
From the outside world a call to the <code>ScreenConductor</code> for this usecase
might look like this.</p>

<p><code>csharp Opening a Screen
var subject = new CSharpFileSubject(@"C:\\end\\of\\the\\world.cs");
screenConductor.OpenScreen(subject);
</code></p>

<p>Notice that all data needed for creating the actual Screen will be passed in with the
concrete <code>ScreenSubject</code> implementation.</p>

<p>``` csharp A ScreenSubject
public class CSharpFileSubject : IScreenSubject
{
  private _fileName;</p>

<p>  public CSharpFileSubject(string fileName)
  {</p>

<pre><code>_fileName = fileName;
</code></pre>

<p>  }</p>

<p>  public bool Matches(IScreen screen)
  {</p>

<pre><code>return screen is SourceCodeScreen &amp;&amp; 
  string.Equals((SourceCodeScreen)screen.FileName, _fileName));
</code></pre>

<p>  }</p>

<p>  public IScreen CreateScreen(IScreenFactory screenFactory)
  {</p>

<pre><code>var screen = screenFactory.Build&lt;SourceCodeScreen&gt;(); 
screen.File = _fileName; 
return screen; 
</code></pre>

<p>  }
}
```</p>

<p>This is not quite the code I would write for a real
system, but I think you get the point. Two methods need to be
implemented for the <code>IScreenSubject</code> interface. This is <code>bool
Matches(IScreen)</code> which identifies a related screen and <code>IScreen
CreateScreen(IScreenFactory)</code> which is used to create the screens. I
really like this kind of API design since it gives you all sorts of
extension points without the need to open up the actual infrastructure.
Want to show a <code>WaitCursor</code> while you create the <code>Screen</code>? Go ahead. Want to
do some loading before the screen is opened? Here's the place to do it .
. . Anyway, the <code>ScreenConductors</code> side of things looks like this.</p>

<p>``` csharp Opening a Screen
public virtual void OpenScreen(IScreenSubject subject)
{
  if (subject.Matches(_screens.Active))
  {</p>

<pre><code>return; 
</code></pre>

<p>  }</p>

<p>  IScreen screen = findScreenMatchingSubject(subject);</p>

<p>  if (screen == null)
  {</p>

<pre><code>screen = createNewActiveScreen(subject);
</code></pre>

<p>  }
  else
  {</p>

<pre><code>activate(screen); 
</code></pre>

<p>  }</p>

<p>  _screens.Show(screen); }
```</p>

<p>Pretty slick, isn't it? The whole code is really dense. Most of the methods involved are not more
than 5 lines long. Finding the related screen for instance is just a
matter of a LINQ-Query on the ScreenCollection using the <code>Matches</code> method
as its predicate.</p>

<p><code>csharp Finding a matching Screen
private IScreen findScreenMatchingSubject(IScreenSubject subject)
{
  return _screens.AllScreens.FirstOrDefault(subject.Matches);
}
</code></p>

<p>Creation of the target screen on the other hand is just a matter of
handing the <code>ScreenFactory</code> (which is actually just a facade to the
IoC-Container of choice) to the subject, activating the created Screen
and adding it to the <code>ScreenCollection</code>.</p>

<p><code>csharp Creating a new Screen
private IScreen createNewActiveScreen(IScreenSubject subject)
{
  IScreen screen = subject.CreateScreen(_factory);
  activate(screen);
  _screens.Add(screen);
  return screen;
}
</code></p>

<p>The last missing piece here is the actual activation of the Screen.</p>

<p><code>csharp Activating a Screen
private void activate(IScreen screen)
{
  _shellService.ActivateScreen(screen);
}
</code></p>

<p>This is delegated to the so called <code>IShellService</code>. You might ask yourself why this
particular dependency exists (at least I did). The main purpose of this
service is mostly the topic of registering Commands and filling up
option panes related to the current Screen. This will be a post on its
own, so don't be mad at me, when I don't cover it today. Instead I would
like to take a look at another common use case:</p>

<h2>Usecase: Closing a Screen </h2>

<p>Now that we've seen how a Screen gets opened, let's take a look
at the other side of the coin, at how it's closed.</p>

<p>``` csharp Closing a Screen
public virtual void Close(IScreen screen)
{
  if (removeScreen(screen))
  {</p>

<pre><code>activateCurrentScreen(); 
</code></pre>

<p>  }
}
```</p>

<p>Most of the handling is in the removeScreen-method (btw, where does this
convention of having all private methods beeing camel-cased come from?
Is this some Java-exposure leaking through? ;-))</p>

<p>``` csharp Removing a Screen
private bool removeScreen(IScreen screen)
{
  if (!screen.CanClose()) return false;</p>

<p>  <em>events.RemoveListener(screen);
  </em>screens.Remove(screen);
  _shellService.ClearTransient();
  return true;
}
```</p>

<p>It delegates the decision whether a screen can be closed
to the screen and in case it can be closed, it removes the screen from
the <code>EventAggregator</code> (<code>_events</code>), from the <code>ScreenCollection</code> (<code>_screens</code>) and
clears its Command-registration (<code>_shellService.ClearTransient()</code>),
before it activates the next screen becoming visible (in case there is one).</p>

<p>``` csharp Activating the current Screen
private void activateCurrentScreen()
{
  IScreen screen = _screens.Active;</p>

<p>  if (screen != null)
  {</p>

<pre><code>activate(screen); 
</code></pre>

<p>  }
}
```</p>

<h2>Usecase: App shutdown coordination </h2>

<p>There is another common usecase implemented by the
<code>ScreenConductor</code> I would like to show you. This is how the whole app
shutdown is coordinated. Prerequesites for this: Instances interested in
beeing notified when the user tries to shut the application down, need
to a) implement the <code>IClosable</code> interface and b) be registered at the
<code>EventAggregator</code>. The latter is done automatically for screens by
the <code>ScreenConductor</code>.</p>

<p><code>csharp The IClosable interface
public interface ICloseable
{
  void AddCanCloseMessages(CloseToken token);
  void PerformShutdown();
}
</code></p>

<p>The <code>IClosable</code> interface just consists of two methods. <code>void AddCanCloseMessage(CloseToken)</code> is called in order
to get feedback from listeners whether the application is allowed to be
shutdown. You can think of <code>CloseToken</code> as a more or less extended version
of <code>CancelEventArgs</code>.</p>

<p>``` csharp The CloseToken class
public class CloseToken
{
  private readonly List<string> _messages = new List<string>();</p>

<p>  public string[] Messages
  {</p>

<pre><code>get { return _messages.ToArray(); 
</code></pre>

<p>  }</p>

<p>  public void AddMessage(string message)
  {</p>

<pre><code>_messages.Add(message); 
</code></pre>

<p>  }
}
```</p>

<p>The following code piece is hooked into the Closing - event of
StoryTellers main window (the shell). It heavily leverages the delegate
based eventing of StoryTellers <code>EventBroker</code> in order to interact with all
interested listeners.</p>

<p>``` csharp Shutdown as implemented in StoryTeller
public bool CanClose()
{
  var token = new CloseToken();</p>

<p>  _events.SendMessage(x => x.AddCanCloseMessages(token));
  bool returnValue = true;</p>

<p>  if (token.Messages.Length > 0)
  {</p>

<pre><code>string userMessage = string.Join("\\n", token.Messages); 
returnValue = _messageBox.AskUser(CAN_CLOSE_TITLE, userMessage); 
</code></pre>

<p>  }</p>

<p>  if (returnValue)
  {</p>

<pre><code>_events.SendMessage(x =&gt; x.PerformShutdown()); 
</code></pre>

<p>  }</p>

<p>  return returnValue;
}
```</p>

<p>One remark to the <code>CanClose()</code> code: <code>_messageBox</code> is just a small wrapper abstraction
in order to make user interaction via message prompts testable. There's
nothing really fancy behind that. I really like the way the app shutdown
is implemented. In fact we've added something very similar in my current
project. However, I'm not so sure when it comes to the question whether
this particular code piece should be part of the <code>ScreenConductor</code>. You
could argue that this method has only very limited cohesion with the
rest of the <code>ScreenConductors</code> methods. In fact most of the stuff the
<code>ScreenConductor</code> interacts with (<code>ScreenCollection</code>, <code>Screens</code>,
<code>ScreenFactory</code>, <code>ScreenSubject</code>) isn't touched in this method. Besides
that, it's code that client application code normally IMHO doesn't need
to or even should call. In our current app we've extracted this
responsibillity into a separate class called the
<code>ApplicationShutdownCoordinator</code> because of that.</p>

<h2>Some more impressions on StoryTellers ScreenConductor </h2>

<p>The exposed API of the <code>ScreenConductor</code> is pretty small, actually only 6 "core" methods and some overloads.
Most of the API really shines. However, besides the already mentioned
<code>CanClose()</code> functionality, there is another functionality which in my
opinion should not be in the ScreenConductor. Can you spot it?</p>

<p><img src="/images/posts/screenconductorinterface1.jpg" alt="image" /></p>

<p><code>LoadHierarchy(Func&lt;Hierarchy&gt;))</code> looks a bit misplaced to me because it
seems to work on a different abstraction level than the rest of the
methods. It looks very application specific, while the rest of the
StoryTeller APIs look very general purpose (independent from the fact
whether Jeremy actually wanted to achieve this or this being just the
result of applying good design practices). Same applies to one of the
messages / events the <code>ScreenConductor</code> is registered for at the
<code>EventBroker</code>, namely <code>DeleteTestMessage</code>. I don't think it should be
directly handled in the <code>ScreenConductor</code>.</p>

<p><img src="/images/posts/screenconductorhandlers.jpg" alt="image" /></p>

<p>A static code analysis might indicate that the <code>ScreenConductor</code> has too
many dependencies. In fact there're 7 direct dependencies injected into
the constructor,</p>

<ul>
<li><code>IEventAggregator</code></li>
<li><code>IScreenCollection</code></li>
<li><code>IScreenFactory</code></li>
<li><code>IApplicationShell</code></li>
<li><code>IShellService</code></li>
<li><code>IScreenObjectLocator</code></li>
<li><code>IMessageCreator</code></li>
</ul>


<p>6 transient dependencies (method parameters or local scope),</p>

<ul>
<li><code>IScreen</code></li>
<li><code>IScreenSubject</code></li>
<li><code>CloseToken</code></li>
<li><code>UserScreenActivation</code></li>
<li><code>OpenItemMessage</code></li>
<li><code>DeleteTestMessage</code></li>
</ul>


<p>and 3 Message interests</p>

<ul>
<li><code>UserscreenActivation</code></li>
<li><code>OpenItemMessage</code></li>
<li><code>DeleteTestMessage</code></li>
</ul>


<p>in the <code>ScreenConductor</code> class. Sounds pretty heavy and like a refactoring
candidate at first. However, as I mentioned earlier, the <code>ScreenConductor</code>
is mostly a <em>Facade</em> with some additional coordination logic in it. When I
say "some additional coordination logic" I mean this literally.
<strong>ScreenConductor has just round about 250 LOC</strong>.</p>

<p>I'm totally ok with this. It certainly has some potential for optimization of the
dependencies (<code>IScreenObjectLocator</code> seems to be at least partially
obsolete, <code>IApplicationShell</code> and <code>IShellService</code> could be merged I guess),
but even without that I consider it a really good example of strong
extensible design for composite desktop apps. For me personally the
<code>ScreenConductor</code> fills a really important gap in the p&amp;p composite app
guidance (be it CAB / SCSF or PRISM). I always had the feeling that I'm
missing something there, but was unable to point out exactly what I've
been missing. This feeling mostly came up when I added some screen
activation or screen creation logic in places that didn't felt right.
Now I know why. Interestingly others <a href="http://neverindoubtnet.blogspot.com/2009/05/birth-and-death-of-m-v-vm-triads.html">observed the need for something similar as well</a>.
Having a <code>ScreenConductor</code> in your application makes IMHO the whole UI
infrastructure a lot more approchable and easier to understand.</p>

<h2>Some final thoughts </h2>

<p>I left the rest of the <code>ScreenConductors</code> code out of
this post intentionally, because if there's one thing I'd like you to
take from this post or even the complete series is that StoryTeller is a
really good learning resource. I really value, what I've learned from
the Dovetail guys while inspecting the code. I wish I had done this
earlier. Good design matters. If you're looking for a place to learn
more about it, the <a href="http://storyteller.tigris.org/source/browse/storyteller/">StoryTeller codebase</a>
might just be the place for you. See you next time, when we take some
time to dig into the command structure of StoryTeller . . .</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diving into the StoryTeller trunk, Part 9: ScreenSubject & ScreenFactory]]></title>
    <link href="http://www.bjoernrochel.de/2009/09/07/diving-into-the-storyteller-trunk-part-9-screensubject-screenfactory/"/>
    <updated>2009-09-07T09:01:19+02:00</updated>
    <id>http://www.bjoernrochel.de/2009/09/07/diving-into-the-storyteller-trunk-part-9-screensubject-screenfactory</id>
    <content type="html"><![CDATA[<p>Hello back again on my little exploration of the UserInterface
implementation of Jeremy Millers StoryTeller. I'd like to start today
with a little excuse (oh my). Although I said last time that the current
post would be focused on the <code>ScreenConductor</code>, I decided to delay that at
least for one post in the series in order to add some content related to
what Jeremy calls <code>ScreenSubject</code> and <code>ScreenFactory</code>. I consider them to be
fairly simple but yet really powerful pattern which can help you a lot
to structure your UI layer, especially the fine line of the UI layer
where the UI infrastructure meets the common application code. It's also
a very good example of applying the Open Closed Principle.</p>

<h2>The common use case for the ScreenSubject</h2>

<p>Lets first start with a little description of the usage of the two
patterns in StoryTeller. When application code wants to open a new
screen in StoryTeller it'll probably use one of the <code>OpenScreen</code> overloads
on the <code>IScreenConductor</code> facade in order to do that.</p>

<p><code>csharp Part of the IScreenConductor interface
public interface IScreenConductor
{
  void OpenScreen(IScreenSubject subject);
  void OpenScreen() where T: IScreenSubject;
}
</code></p>

<p>The common use case for the <code>ScreenSubject</code> can be easily depicted using a tool we all know quite
well, Visual Studio. Think about it: What happens when you click onto a
source code file in the Source Code Explorer for the first time? Well, a
new tab is created displaying the content of the file. However, if you
click the item in the Source Control Explorer the second time, the
previously created tab gets activated and NO NEW TAB IS CREATED.</p>

<h2>How is this implemented</h2>

<p>Let's take a look at how this behavior is implemented in StoryTeller.
The following code snippet shows a very small part of the
<code>ScreenConductor</code>. I've inline some comments in order to make it more
visible what is going on there.</p>

<p>``` csharp The OpenScreen method</p>

<p>public virtual void OpenScreen(IScreenSubject subject)
{
  //<em>screens is of type IScreenCollection
  if (subject.Matches(</em>screens.Active))
  {</p>

<pre><code>return; 
</code></pre>

<p>  }</p>

<p>  //This simply makes a LINQ-lookup on the ScreenCollection
  //using ScreenSubject.Matches as a predicate
  IScreen screen = findScreenMatchingSubject(subject);</p>

<p>  if (screen == null)
  {</p>

<pre><code>//This passes the global IScreenFactory into the 
//ScreenSubjects CreateScreen method in order to create 
//the screen. 
screen = createNewActiveScreen(subject); 
</code></pre>

<p>  }
  else
  {</p>

<pre><code>activate(screen); 
</code></pre>

<p>  }</p>

<p>  _screens.Show(screen);
}
<code>``
The</code>IScreenSubject` abstraction plays a quite important role in this use case. The interface defines
only two methods matching the responsibilities of the ScreenSubject</p>

<p><code>csharp The IScreenSubject interface
public interface IScreenSubject
{
  bool Matches(IScreen screen);
  IScreen CreateScreen(IScreenFactory factory);
}
</code>
As we saw in the <code>ScreenConductor</code> snippet the <code>Matches</code>
method is used as a predicate in order to find the related screen. The
<code>CreateScreen</code> method isn't directly shown in the snippet, but it's not
that complicated. It's responsible for coordinating the creation of a
screen. When I say coordination I'm referring to the fact that the
actual screen creation is the responsibility of the <code>IScreenFactory</code>
(which is just a simple wrapper around StructureMap).</p>

<p><code>csharp The IScreenFactory interface
public interface IScreenFactory
{
  T Build&lt;T&gt;() where T : IScreen;
  IScreen&lt;T&gt; Build&lt;T&gt;(T subject);
}
</code></p>

<p>With this design in place we have a very nice extension point in place to do all kinds of
things around the screen creation. Want to do some deferred data loading
before the screen is shown? That's your place. Maybe you want to show
some progress indicator while doing this. Guess what, that's your place
to do this. And the best of it: The screen doesn't have to know anything
of this, you can free him of this kind of logic. There're some base
classes which provide some base implementation for different use cases
in StoryTeller. I'm only going to show one of them, the
<code>ScreenSubject&lt;T&gt;</code>. This class adds a bit generics on top of the
ScreenSubject (in order to allow auto-registration using StructureMaps
convention over configuration features).</p>

<p>``` csharp ScreenSubject<T>
// Marker interface
public interface IScreenSubject<T> : IScreenSubject { }</p>

<p>public class ScreenSubject<T> : IScreenSubject<T>
{
  private readonly T _subject;</p>

<p>  public ScreenSubject(T subject)
  {</p>

<pre><code>_subject = subject; 
</code></pre>

<p>  }</p>

<p>  #region IScreenSubject Members</p>

<p>  public bool Matches(IScreen screen)
  {</p>

<pre><code>var specific = screen as IScreen; 

if (specific == null) 
  return false;

return specific.Subject.Equals(_subject); 
</code></pre>

<p>  }</p>

<p>  public IScreen CreateScreen(IScreenFactory factory)
  {</p>

<pre><code>return factory.Build(_subject);
</code></pre>

<p>  }</p>

<p>  #endregion</p>

<p>  public bool Equals(ScreenSubject<T> other)
  {</p>

<pre><code>if (ReferenceEquals(null, other)) 
  return false; 

if (ReferenceEquals(this, other)) 
  return true; 

return Equals(other._subject, _subject); 
</code></pre>

<p>  }</p>

<p>  public override bool Equals(object obj)
  {</p>

<pre><code>if (ReferenceEquals(null, obj))
  return false; 

if (ReferenceEquals(this, obj)) 
  return true; 

if (obj.GetType() != typeof (ScreenSubject&lt;T&gt;)) 
  return false; 

return Equals((ScreenSubject&lt;T&gt;) obj); 
</code></pre>

<p>  }</p>

<p>  public override int GetHashCode()
  {</p>

<pre><code>return _subject.GetHashCode(); 
</code></pre>

<p>  }
}
<code>``
The basic idea used in this implementation of</code>IScreenSubject<code>is that a</code>ScreenSubject<code>is related
to a single data instance. Coming back to the Visual Studio example,
this could have been represented as something like
</code>ScreenSubject<SourceCodeFile>`. Really interesting . . .</p>

<p>The last code snippet for today I'd like to show is how the <code>ScreenFactory</code> is actually
implemented. As usual really short, not very much code.</p>

<p>``` csharp The ScreenFactory
public class ScreenFactory : IScreenFactory
{
  private readonly IContainer _container;</p>

<p>  public ScreenFactory(IContainer container)
  {</p>

<pre><code>_container = container; 
</code></pre>

<p>  }</p>

<p>  #region IScreenFactory Members</p>

<p>  public SCREEN Build<SCREEN>() where SCREEN : IScreen
  {</p>

<pre><code>return _container.GetInstance&lt;SCREEN&gt;(); 
</code></pre>

<p>  }</p>

<p>  public IScreen<T> Build(T subject)
  {</p>

<pre><code>return _container.With(subject).GetInstance&lt;T&gt;(); 
</code></pre>

<p>  }</p>

<p>  #endregion
}
```
I really like the way how StructureMap allows injecting transient
parameters in the resolution process . . .</p>

<h2>Closing thoughts</h2>

<p>I'm honest with you. I consider <code>ScreenSubject</code> to be one of the most
valuable patterns I've learned so far while playing with the StoryTeller
sources. It provides such a nice extension point for screen
initialization. I think it's one of those patterns you don't know how
much you miss it until you see it for the first time and recognize how
much it could have helped you in the past. At least that was my
reaction. In the past I've put a lot of the functionality which resides
in StoryTeller in <code>ScreenSubject</code> implementations on my screens which
polluted my screens with a lot of initialization code and sometimes
(especially when you have high network latency) doesn't even really look
good (I bet you know what I'm talking about, don't you? I bet a lot of
you have seen the frozen screen, too). The <code>ScreenSubject</code> pattern was
introduced to my project last week and what can I say: I'm pretty happy
to have it in our application ;-)</p>
]]></content>
  </entry>
  
</feed>

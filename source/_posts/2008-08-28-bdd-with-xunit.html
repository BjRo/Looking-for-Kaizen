---
author: BjRo
date: '2008-08-28 11:53:06'
layout: post
slug: bdd-with-xunit
status: publish
title: BDD with Xunit
wordpress_id: '100'
? ''
: - BDD
  - BDD
  - Uncategorized
  - Uncategorized
  - xUnit
  - xUnit
  - BDD
  - BDD
  - xUnit
  - xUnit
---

My current tool of interest is XUnit. For those of you who haven't heard of it it's a relatively new unit testing framework from Brad Wilson and the original author of NUnit 2.0, James Newkirk. You can find it <a href="http://www.codeplex.com/xunit" target="_blank">here</a>.

Some of the things I really like about it:
<ul>
	<li>It has a set of .NET 3.0 Extension methods, which can be used instead of classic assertions (f.e.: "Foo".ShouldNotBeNull() )</li>
	<li>It runs every every test on a separated instance.</li>
	<li>It uses the constructor of the test class and the Dispose-pattern for fixture initialization and release of resources after a test.</li>
	<li>It's relatively easy to extend XUnit.</li>
</ul>
Because of curiosity and my current affection with BDD I decided to port the BDDExtension stuff fromÂ  JP Boodhoo to XUnit. So here we go:

<strong>Marking specifications with concerns
</strong>

All specifications for a particular type are marked with the <em>ConcernAttribute</em>.Â  This is only a marker attribute by which a tool like <em>bddunit </em>is able to correlate specifications and their related type.

[sourcecode language="csharp"]
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
public class ConcernAttribute : TraitAttribute
{
        private readonly Type _Type;

        public ConcernAttribute(Type type) : base("Concern", type.FullName)
        {
                _Type = type;
        }

        public Type Type
        {
                get { return _Type; }
        }
}
[/sourcecode]

The <em>ConcernAttibute </em>extends the <em>TraitAttribute </em>which is described in the documentation as "an Attribute used to decorate a test method with arbitrary name/value pairs ("traits")." I changed the <em>AttributeTarget </em>from method to class in order to suit my needs.

<strong>Changing the way the test is executed</strong>

JP's original code relied on the SetUp and Teaddown handlers of NUnit / MBUnit which are execute before and after each test method in the same class. Since XUnit doesn't have that feature any more we'll have to extend it a bit.

The main extension point for how a test is executed is the <em>FactAttibute </em>used to mark a method as a test. You can extend it and return a different <em>ITestCommand </em>which is then used to execute the test.

[sourcecode language="csharp"]
public class ObservationAttribute : FactAttribute
{
        protected override IEnumerable EnumerateTestCommands(MethodInfo method)
        {
                var testCommand = base.EnumerateTestCommands(method).First();
                yield return new SpecificationTestCommand(testCommand, method);
        }
}
[/sourcecode]

Do you wonder why the method returns an <em>IEnumerable&lt;ITestCommand&gt;</em>? This is done in order to support something like row tests in MBUnit. The XUnit framework basically enables you to run a test several times. For me this isn't interesting so I just grabbed the first <em>ITestCommand </em>from it and wrapped it with my own implementation, which looks like this:

[sourcecode language="csharp"]
public class SpecificationTestCommand : BeforeAfterCommand
{
        public SpecificationTestCommand(
                ITestCommand innerCommand,
                MethodInfo testMethod)
                : base(innerCommand, testMethod)
        {
        }

        public override MethodResult Execute(object testClass)
        {
                var specification = testClass as IContextSpecification;

                if (specification == null)
                {
                       throw new InvalidOperationException(
                          "Instance does not implement IContextSpecification");
                }

                try
                {
                        specification.EstablishContext();
                        specification.Because();
                        return base.Execute(testClass);
                }
                catch(AssertException)
                {
                        throw;
                }
                catch (Exception exception)
                {
                        ExceptionUtility.RethrowWithNoStackTraceLoss(exception.InnerException);
                }

                return null;
        }
}
[/sourcecode]

The code requires the test class to implement the <em>IContextSpecification </em>interface in order to invoke the <em>EstablishContext()</em> and <em>Because()</em> methods for doing AAA based tests. (Do you miss AfterEachSpec? One moment please :-)) For every interface there is a base class which is in my case the <em>ContextSpecification</em> class.

[sourcecode language="csharp"]
public abstract class ContextSpecification : IContextSpecification, IDisposable
{
      protected abstract void Because();

      protected abstract void EstablishContext();

      protected virtual void AfterEachSpec()
      {
      }

      #region IContextSpecification Members

      void IContextSpecification.Because()
      {
            Because();
      }

      void IContextSpecification.EstablishContext()
      {
            EstablishContext();
      }

      #endregion

      #region IDisposable Members

      public void Dispose()
      {
            AfterEachSpec();
      }

      #endregion
}
[/sourcecode]

Notice some things.<em> AfterEachSpec()</em> is called from <em>Dispose()</em>, That's why I didn't need to include it into the <em>IContextSpecification</em> interface. That interface is implemented explicitly in order to allow the hooks to have different modifiers (protected).

<strong>A first test</strong>

There's always an interesting moment when you first run your little experiment. Here we go:

[sourcecode language="csharp"]
[Concern(typeof(Factory))]
public class When_creating_product_with_a_valid_name : ContextSpecification
{
      private Factory _Factory;
      private Product _CreatedProduct;

      protected override void EstablishContext()
      {
            _Factory = new Factory();
      }

      protected override void Because()
      {
            _CreatedProduct = _Factory.Create("Foo");
      }

      [Observation]
      public void The_product_should_contain_the_correct_name()
      {
            _CreatedProduct.Name.ShouldEqual("Foo");
      }

      [Observation]
      public void The_product_should_contain_the_correct_vendor_name()
      {
            _CreatedProduct.VendorName.ShouldEqual("FooVendor");
      }
}
[/sourcecode]

And the result from TestDriven.NET is:

------ Test started: Assembly: Xunit.BddExtensions.Samples.dll ------
2 passed, 0 failed, 0 skipped, took 0,92 seconds.

<strong>Conclusions</strong>

It's in fact very easy to extend XUnit. I like the tool even more after doing this little research. The shown code runs smoothly with TestDriven.NET. However the Resharper - TestRunner seems to have problems with it (TestExplorer stays blank).

I'll play with that approach in the next few weeks and will blog about my experience with both XUnit and BDD. So if you're interested in more stay tuned . . .

P.s.: If you're interested in the code, just drop me a line . . .
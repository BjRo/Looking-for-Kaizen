---
author: BjRo
date: '2008-07-02 18:21:03'
layout: post
slug: yet-another-way-to-do-publish-subscribe-part-ii
status: publish
title: Yet another way to do publish & subscribe Part II . . .
wordpress_id: '9'
? ''
: - Uncategorized
  - Uncategorized
  - Castle Windsor
  - Castle Windsor
  - Inversion of Control
  - Inversion of Control
  - Publish &amp; subscribe
  - Publish &amp; subscribe
---

As promised on the last post, this time I talk more about what I actually implemented. Let's start with the basic API. The whole API is very simple and message centered. In order to be able to recieve messages you have to implement the <strong>ISubscriber&lt;TMessage&gt;</strong> interface.

[sourcecode language='csharp']
public interface ISubscriber<TMessage>
{
     void Handle(TMessage message);
}
[/sourcecode]
The generic parameter <strong>TMessage </strong>specifies the type of message the subscriber is interested in.Â  The message should simply be implemented by a POCO. Examples could be:
<ul>
	<li>ISubscriber&lt;ActivePatientChanged&gt;</li>
	<li>ISubscriber&lt;ApplicationTitleChanged&gt;</li>
	<li>ISubscriber&lt;CsvExportFinished&gt;</li>
</ul>
A consumer class wants to publish messages or to register itsself for a particular message needs to have a reference to an <strong>IMessageBus </strong>implementation. This interface serves as a consumer side facade to the pubsub system.

[sourcecode language='csharp']
public interface IMessageBus
{
      void AddSubscriber(ISubscriber subscriber);
      void ReleaseSubscriber(ISubscriber subscriber);
      void SendMessage<TMessage>(TMessage message);
}
[/sourcecode]

From a consumer perspective that's all your need to known when dealing with publish &amp; subscribe. Together with type inference it's event nicer to use :-).
[sourcecode language='csharp']
public class DemoMessage
{
}

public class MyListener : ISubscriber<DemoMessage>
{
     public void Subscribe(IMessageBus bus)
     {
          bus.AddSubscriber(this);
     }
 
     public void Handle(DemoMessage message)
     {
     }
}

public class MyPublisher
{
     private IMessageBus _Bus;

     public MyPublisher(IMessageBus bus)
     {
          _Bus = bus;
     }

     public void Demo()
     {
         _Bus.SendMessage(new DemoMessage());
     }
}
[/sourcecode]

Some other characteristics also worth mentioning:
<ul>
	<li>The current implementation captures the thread context when a subscriber is registered. All callbacks will be handled on the same thread on which they were registered.</li>
	<li>Only a weak reference is held to the subscriber. This guarantees that a subscriber can be garbage collected although not properly unregistered from the publish &amp; subscribe system. The implementation detects dead references and removes them automatically.</li>
</ul>
With that beeing said I would like too conclude the series about publish &amp; subscribe with a post about the actual implementation which will follow up . . .